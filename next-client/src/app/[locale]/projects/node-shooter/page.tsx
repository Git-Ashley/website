import { BlurFade } from "@/components/ui/blur-fade";
import { Link } from "@/src/i18n/routing";
import { getTranslations, setRequestLocale } from "next-intl/server";
import { Suspense } from "react";
import { Placeholder } from "../project-placeholder";

type Props = {
  params: Promise<{locale: string}>;
};

export default async function NodeShooter({ params }: Props) {
  const t = getTranslations('');
  const { locale } = await params;
  setRequestLocale(locale);
  return (
    <Suspense fallback={<Placeholder/>}>
      <BlurFade className="max-w-[800px] mx-auto">
        <section className="container">
          <div className="col-md-10 col-md-offset-1">
            <div className="text-center text-[23px]/[30px] font-medium">Node Shooter</div>
            <br/>
            <div className="font-medium">
              Node Shooter has been integrated into the <Link className="cursor-pointer" locale={locale} href="/projects/social-app/lobby">Social App</Link> project. You can read about it below.
            </div>
            <div className="mt-2 space-y-2">
              <p>{"This mini-project was born from an idea to create a 'loopless' game engine for the server side of a multiplayer game, so that game loops are executed via events, rather than a given number of times per second. For many types of games, this could save a lot on resource usage, especially if players are idling or causing few events."}</p>

              <p>{"Instead of calculating movement and collisions through the traditional method of checking if objects cross each other 20-30 times per second), it uses an events-based system where objects are updated, and collisions are calculated (via mathematical interpolation) only when events are generated by users or generated from collisions."}</p>

              <p>{"The downside is collisions are more complicated to calculate. First, it must be calculated if a collision will occur in the first place, and if so, how long from now, but only provided the colliding objects remain on course. If one of them changes course (or one of it's properties changes), then the forecasted collision event is cancelled. In theory, this should substantially reduce server load due to only needing to update objects, calculate collisions and send messages to each player as and when events occur, rather than 20-30 times per second as is usually the case with game loops."}</p>

              <p>{"It works best with slower paced games with not too many players/NPCs where events will (on avg.) occur less than 20 times per second. If there are more than ~25 events occuring per second then it may start to perform worse than the traditional method. In Node Shooter, I have demonstrated how collisions between circular objects can be calculated using trigonometry. Objects of other shapes (maybe except ellipses) will likely require a completely different algorithm. Note that trig approximations should be used instead in a real game due to the poor performance of javascript trigonometry functions."}</p>
            </div>
          </div>
        </section>
      </BlurFade>
    </Suspense>
  )
}