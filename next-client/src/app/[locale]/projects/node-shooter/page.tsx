import { BlurFade } from "@/components/ui/blur-fade";
import { Link } from "@/src/i18n/routing";
import { getTranslations, setRequestLocale } from "next-intl/server";

type Props = {
  params: Promise<{locale: string}>;
};

export default async function NodeShooter({ params }: Props) {
  const t = getTranslations('');
  const { locale } = await params;
  setRequestLocale(locale);
  return (
    <BlurFade>
      <section className="container">
        <div className="col-md-10 col-md-offset-1">
          <div className="text-center text-[23px]/[30px] font-medium">Node Shooter</div>
          <br/>
          <div className="font-medium">
            Node Shooter has been integrated into the <Link className="cursor-pointer" locale={locale} href="/projects/social-app">Social App</Link> project. You can read about it below.
          </div>
          <div className="mt-2 space-y-2">
            <p>{"This mini-project was born from an idea I had to create a 'loopless' game engine for the server side for  multiplayer online games, so that game loops are executed via events, rather than a given number of times per second. For many types of games, this could save a huge amount on resources, especially if players are idling and not causing any events to fire."}</p>

            <p>{"Instead of calculating movement and collisions through the traditional method (checking if objects 'cross over' each other 20-30 times per second), it uses an events-based system; objects are updated, and collisions are calculated (via mathematical interpolation) only when events are generated by users or generated from collisions."}</p>

            <p>{"The collision engine was the main hurdle. First it calculates if a collision will occur in the first place, and if so, how long from now, but only provided the colliding objects remain on course. If any of the objects change size or direction then the 'not yet activated' collision event is cancelled. In theory, this should substantially reduce server load due to only needing to update objects, calculate collisions and send messages to each player as and when events occur, rather than 20-30 times per second as is usually the case with game loops."}</p>

            <p>{"It works best with slower paced games with not too many players/NPCs where events will (on avg.) occur less than 20 times per second. If there are more than ~25 events occuring per second then it may start to perform worse than the traditional method. For now, I have only made it to work between circular objects. Objects of other shapes (maybe except ellipses) will likely require a completely different algorithm. Modifying the current algorithm to work with ellipses and an algorithm to work with any polygon (with all angles &lt;180 degrees) should be able to cover all cases."}</p>
          </div>
        </div>
      </section>
    </BlurFade>
  )
}