{
  "CV": "Resume",
  "Projects": "Projects",
  "Project": "Project",
  "MORE": "More",
  "Summary": "Summary",
  "Samples": "Samples",
  "MEMAPP_DESCRIPTION": "Memapp is based on the spaced repetition learning (SRL) technique. This is a project which I originally created for learning Japanese Kanji characters, since I wasn't happy with other SRL apps available at the time.",
  "SOCIAL_APP_SUMMARY": "Lobby integrated with Node Shooter",
  "MEMAPP_SUMMARY": "Spaced repetition learning app",
  "ROOM__SUMMARY": "Client & Backend package to aid with communication for a room of clients",
  "NS_SUMMARY": "Loopless game server experiment",
  "AP_SUMMARY": "Implementation of the Auslander-Parter planarity testing agorithm",
  "homepage": {
    "TITLE": "Senior Software Engineer",
    "XP": "7Â½ years professional experience",
    "LANGS": "English (native), French (B2/C1)"
  },
  "cvpage": {
    "work_xp": "Work Experience",
    "EDUCATION_SECTION_TITLE": "Education & certificates",
    "QUADRIVIA": "3 month contract. I helped to bring a greenfield project up a few gears. Started by updating to TS, Vite, Tailwind, ShadCN, React Router v7 and Storybook from CRA + JS. Then built out the front-end foundations for \"Qu for Clinicians\" - an AI helper for clinicians to manage patients.",
    "PLENTIFIC": "Worked on a marketplace platform for contractors and property agents. I led several projects from conception to release, and was the go to person for refactoring large modules of unruly code. I made heavy use of React Query here, which replaced Flux, simplified data flow and reduced unnecessary data fetching.",
    "FEEDR": "Worked with various services, web apps and mobile apps to connect food suppliers with employers. Duties involved owning projects, unit testing, feature development/enhancement, code reviews.",
    "IMANAGE": "Worked on the frontend, and devops. Created/improved features to allow users to extract data from potentially millions of documents via AI. I also created a custom solution to run cypress tests in parallel, which massively sped up completion time of the test suite.",
    "SUPERCARERS": "Developed features for a marketplace style app where people looking for carers can be matched with carers who bid for work. Also created in-house admin tools for our staff to manage clients and carers.",
    "D2R": "Developed features and foundations of a recruitment app (greenfield project), aimed at trades people.",
    "ANCOA": "C++ Full-stack role. I created algorithms to help detect fraudulent behaviour in stock markets, as well as contributing to other areas of the system, data-integration, database management, linux build system, desktop and web front-end, client APIs and some client-facing tasks and attendance of Fintech events. Joined the web team full-time for last 5 months there and helped develop the web interface with AngularDart.",
    "APAK": "Worked closely with business analysts to enhance and develop new features.",
    "TCF": "Speaking & Writing: NCLC 8 / B2+. Reading: NCLC 7 / B2. Listening: NCLC 10 / C2.",
    "TCF_SUBTITLE": "French language proficiency test; Upper intermediate / advanced.",
    "JAN": "January",
    "FEB": "February",
    "MAR": "March",
    "APR": "April",
    "MAY": "May",
    "JUN": "June",
    "JUL": "July",
    "AUG": "August",
    "SEP": "September",
    "OCT": "October",
    "NOV": "November",
    "DEC": "December"
  },
  "roomsummary": {
    "TITLE": "Room pattern",
    "TITLE_2": "Client Pooling",
    "TITLE_3": "Socket Handler",
    "TITLE_4": "Features",
    "LINE_1": "The Room package is designed to be used whenever there are multiple clients communicating with each other via a central server. Usually there's a lot of setup involved with creating such rooms including setting up the websocket server, working out when the client is initialized and ready to receive the initial rooms state, and cleaning up resources such as event listeners, and if you want to implement more advanced functionality such as disconnect/reconnect management, then things can get messy. This room package is designed to greatly simplify all of this.",
    "LINE_2": "All of the features are demonstrated in the",
    "LINE_3": "samples section",
    "LINE_4": "The server side module exports a class,",
    "LINE_5": "which is intended to be extended from, and exposes hooks, while",
    "LINE_6": "the client side module",
    "LINE_7": "is just a simple interface to the corresponding room on the server. There are 6 samples which walk you through how to use the room package to build a chat-room. Sample 1 shows simple setup, and a feature-less basic chat-room. Samples 2 - 5 each demonstrate a different feature; Disconect/reconnect functionality, permissions, initialization and multiple rooms of the same type, while sample 6 demonstrates them all working together.",
    "LINE_8": "The server side Room module stores clients by session ID, which has a natural side effect of multiple clients over different devices being able to log into the same user unless you choose to disallow it via the",
    "LINE_9": "permission hook",
    "LINE_10": "objects are created to represent each client session, and placed in a client pool so that each Room can share the client connection. This client pool is not exposed to code using the module. Clients are automatically removed from the pool if they are no longer in any rooms which it provides for.",
    "LINE_11": "The Room pattern makes use of the SocketHandler class, with each",
    "LINE_12": "object on the server containing a SocketHandler. It is a wrapper for the raw websocket and handles the disconnect/reconnect functionality with pings/pongs, and emits 'disconnect' upon disconnecting, in which case the client side SocketHandler goes into reconnect mode, and the SocketHandler will emit a 'reconnect' event upon reconnecting, with the ability the reassign the raw websocket reference to the new one. It also follows socket.io's message sending style of emitting an event with a payload, but is a lot more lightweight. The client side SocketHandler can handle cases where messages are sent while the connection is initializing via an _enqueue function."
  },
  "roomsamples": {
    "and": "and",
    "TITLE_1": "Sample 1: Basics",
    "TITLE_2": "Sample 2: Disconnecting & reconnecting",
    "TITLE_3": "Sample 3: Permissions",
    "TITLE_4": "Sample 4: Initialization hook",
    "TITLE_5": "Sample 5: Multiple rooms of the same type",
    "TITLE_6": "Sample 6: Everything together",
    "LINE_0": "There are 6 samples:",
    "LINE_1": "is a simple chat room example. If you're testing it on your own, use two separate browsers or a browser with incognito mode to log into multiple accounts. The server side room module doesn't allow multiple clients with the same session ID, stored in the Cookie header.",
    "LINE_2": "On the client side, the main part to take note of is the login() function. The rest is mostly DOM manipulation.",
    "LINE_3": "Above is an excerpt from the client sample. To create a client room you must always construct a new room and use",
    "LINE_4": "to request to join that room. If unsuccessful an exception will be thrown with err being a string, for the reason of the failure. Upon success, this is the time to initialize the client. Once you have finished initializing, call",
    "LINE_5": "as shown, which will notify the corresponding room on the server that you have finished initializing.",
    "LINE_6": "Now for the server side code,",
    "LINE_7": "Firstly it is important to note you must pass the http server to",
    "LINE_8": "and your session ID string name in the cookie, with the  sidCookie prop in the optional 2nd argument (default to 'sid').",
    "LINE_9": "This is the API endpoint which chatRoom.join('/chatroom') posts to in the client sample, and is where permission is requested to join the room. The",
    "LINE_10": "is demonstrated in sample 3, but if you do not implement it in your subclass, then permission will always be granted to join. Once permission to join has been granted, the client is added to the room in an uninitialized state and will not yet receive broadcasted messages. A useful hook",
    "LINE_11": "is called at this time too, demonstrated in sample 4. If your Room server is at a different URL to your API, or you want to specify a path, you can add a 'url' property onto the result object here. It can be a relative path or an absolute URL.",
    "LINE_12": "This is our subclass which extends Room, and implements only two client hooks. initClient is called when a client has called",
    "LINE_13": "from the first code sample on the client side, so you can safely assume here that the client is all initialized, and is a good place to set the listeners. The",
    "LINE_14": "hook is called when a client leaves, which can happen in a number of ways. Both",
    "LINE_15": "modules have a leave method, with the server-side module taking a client parameter. Also if you haven't implemented disconnect/reconnect functionality, a disconnect will automatically boot the player from the room.",
    "LINE_16": "The SocketHandler class (read about it in the",
    "LINE_17": "section) can detect disconnects and reconnects, and will try to reconnect when the connection is lost. The server-side Room module allows you to access",
    "LINE_18": "hooks, when this happens. To stop players being booted from the room upon disconnect, you must pass a reconnectTimeout property in the",
    "LINE_19": "as follows:",
    "LINE_20": "The parameter is in milliseconds. This will boot the client from the room if they have not reconnected within 15 seconds. It defaults to 0. Passing a negative number will disable the auto-boot completely. Now we can implement the disconnect and reconnect hooks as shown below.",
    "LINE_21": "That's all that's required to implement reconnect functionality on the server. For the client side, if a user has disconnected, a message will be printed in the chat room message area, as well as their name in the user list graying out. If they do not reconnect within 15 seconds they will leave, and if they reconnect before then, their name will go back to white with a reconnect message in the chat area. The only new events added to the chat room are shown below.",
    "LINE_22": "This sample demonstrates how to grant or refuse permission. Here, we refuse permission to join if the username entered is longer than 8 characters, or if its empty. To do this, all we need to do is implement the",
    "LINE_23": "hook on the server-side ChatRoom class, as shown below.",
    "LINE_24": "Now, if we enter no name, or a name longer than 8 characters, the error reason will be caught and printed to the developer console.",
    "LINE_25": "Here, the",
    "LINE_26": "hook is demonstrated, which is useful for a few reasons. First is that it allows us to broadcast that a user is joining, but not yet initialized, and second; it allows us to add a user to the room before the user has initialized, which can be useful if we have a user limit for our room, to avoid a conflict if two users request to join (see sample 3) at the same time for the last spot.",
    "LINE_27": "All that has been changed to the client from sample 1 is a new 'USER_INITIALIZED' websocket event for when the user has finished initializing, and the initialized() callback has been wrapped in a setTimeout to simulate initialization.",
    "LINE_28": "For the backend, things have been moved around a little. The user now gets created in onClientAccepted, and the 'USER_JOINED' has been moved to the new onClientAccepted hook, while being replaced with 'USER_INITIALIZED'.",
    "LINE_29": "Sample 5 demonstrates that you can easily join multiple rooms of the same type without having to worry about conflicting events on the server or client thanks to the way the rooms on the client/server precede events with an agreed unique ID behind the scenes. Here, the backend code has been changed to require logging in before joining a room, which no longer requires POST data to be sent in the join rooms' request, and we now have 4 chat-rooms, and require a parameter ID for the room you wish to join for the /chatroom POST endpoint.",
    "LINE_30": "For the client, when you login now, you are presented with 4 rooms which you can join. The code for the client is mostly the same apart from it has been factored into its own class (in",
    "LINE_31": "with the constructor taking an integer for the room number and there is a new renderJoinBtn function so each room can have its own join button. Normally web components should be used here, but the spec is too unstable at the moment, and using babel or React isn't worth it for such a small sample, so we just use a class which manipulates the DOM when it is constructed.",
    "LINE_32": "Sample 6 combines everything from the previous samples. The disconnect/reconnect functionality is more interesting too, since if you disconnect and only rejoin a single room, you can still be booted from the other rooms if you don't join back in time. Also the onJoinRequest is used to refuse permission to join a room if you're already a member of another 3. Upon attempting to join a 4th, you will be refused permission and a message will be printed to the developer console stating this."
  },
  "roomdocs": {
    "LINE_1": "See",
    "LINE_2": "API docs",
    "LINE_3": "on Github"
  },
  "appage": {
    "LINE_1": "This project involves the design and implementation of algorithms on graphs with the main one being the Auslander-Parter planarity testing algorithm. Users can choose to draw their own graphs or select from a list of demo graphs.",
    "LINE_2": "NOTE BEFORE USING THE SOFTWARE:",
    "LINE_3": "This implementation of the Auslander-Parter algorithm only operates on",
    "LINE_4": "biconnected graphs",
    "LINE_5": "so be sure any custom drawn graphs are biconnected. Adapting the algorithm to detect and test each biconnected component is possible but is beyond the scope of the project.",
    "LINE_6": "On the graph-drawing panel (or the panel after you select a demo graph)... The text on the buttons may be cut off on some devices. The ordering is: \"Submit\", \"Back\", \"Clear\" (graph drawing), \"Help\" (for draw instructions)",
    "LINE_7": "In the next panel (from the graph-drawing panel), the 3 buttons at the top is for the algorithm mode; just select AP-Alg if you are unsure.",
    "LINE_8": "Download:",
    "LINE_9": "It has been tested with Java 1.7 and 1.8. 1.6 and lower may or may not work.",
    "LINE_10": "Note: This project was originally part of a maths degree and even though it has been re-written since, I was still a novice developer at the time of the re-write, so some design choices will be questionable to professional developers.",
    "LINE_11": "View code on Github",
    "LINE_12": "The relevant section of my dissertation to understand how the Auslander-Parter algorithm works:"
  }
}
